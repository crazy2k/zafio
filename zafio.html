
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Zafio por dentro &mdash; Zafio v0.1 documentation</title>
    <link rel="stylesheet" href="static/flasky.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="static/translations.js"></script>
    <link rel="top" title="Zafio v0.1 documentation" href="index.html" />
    <link rel="next" title="Instalación y uso" href="install.html" />
    <link rel="prev" title="Un poco de background" href="background.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="static/small_flask.css" type= "text/css" rel="stylesheet" />

  </head>
  <body>
    <div class="related">
      <h3>Navegación</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="Índice General"
             accesskey="I">índice</a></li>
        <li class="right" >
          <a href="install.html" title="Instalación y uso"
             accesskey="N">siguiente</a> |</li>
        <li class="right" >
          <a href="background.html" title="Un poco de background"
             accesskey="P">anterior</a> |</li>
        <li><a href="index.html">Zafio v0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="zafio-por-dentro">
<h1>Zafio por dentro<a class="headerlink" href="#zafio-por-dentro" title="Enlazar permanentemente con este título">¶</a></h1>
<p>Zafio es un sistema operativo básico y poco sofisticado. Algunas de sus
características salientes son:</p>
<ul class="simple">
<li><strong>carga de programas</strong> desde ejecutables ELF</li>
<li><strong>protección de memoria</strong> utilizando paginación y espacios de memoria
diferentes para las tareas</li>
<li>manejador de interrupciones que permite el <strong>registro de
handlers en tiempo de ejecución</strong></li>
<li><strong>scheduling de procesos utilizando round-robin</strong> con un quantums
modificables por el usuario</li>
<li><strong>task-switching por software</strong></li>
<li>atención de <strong>llamadas al sistema</strong> (bloqueantes y no bloqueantes)</li>
</ul>
<p>En este documento se describen estas y otras características de Zafio.</p>
<div class="section" id="la-estructura-de-directorios">
<h2>La estructura de directorios<a class="headerlink" href="#la-estructura-de-directorios" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Si bien la parte más importante de Zafio está escrita en C, en realidad,
el proyecto también se compone de archivos con código <em>assembly</em> de x86,
<em>scripts</em> de utilidad y de configuración de herramientas, archivos
binarios y documentación. Todo estos archivos están organizados en una
estructura de directorios que facilita su búsqueda.</p>
<p>Esta es una síntesis de la estructura de directorios del proyecto:</p>
<p class="graphviz">
<img src="images/graphviz-c83ec6e99f0688464bb6971a90efd64efd2157a3.png" alt="digraph direcciones {
    ranksep=0.3

    &quot;raíz&quot; [shape=box]
    &quot;doc/&quot; [shape=box]
    &quot;kernel/&quot; [shape=box]
    &quot;user/&quot; [shape=box]
    &quot;progs/&quot; [shape=box]
    &quot;reftest/&quot; [shape=box]
    &quot;raíz&quot; -&gt; &quot;doc/&quot;
    &quot;raíz&quot; -&gt; &quot;kernel/&quot;
    &quot;raíz&quot; -&gt; &quot;user/&quot;
    &quot;raíz&quot; -&gt; &quot;progs/&quot;
    &quot;raíz&quot; -&gt; &quot;reftest/&quot;
}" />
</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Directorio</th>
<th class="head">Contenido</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><strong>raíz</strong></td>
<td>representa la base de la estructura de directorios. Además
de contener al resto de los directorios, posee archivos de
alcance global en el proyecto.</td>
</tr>
<tr><td><strong>doc/</strong></td>
<td>contiene los fuentes de la documentación y algunas
utilidades para construirla.</td>
</tr>
<tr><td><strong>kernel/</strong></td>
<td>posee los encabezados y el código del kernel, y además
alberga los archivos objeto resultantes de su compilación.</td>
</tr>
<tr><td><strong>user/</strong></td>
<td>es análogo a <em>kernel/</em>, sólo que para código de usuario.</td>
</tr>
<tr><td><strong>progs/</strong></td>
<td>contiene ejecutables que Zafio puede ejecutar una vez
cargado.</td>
</tr>
<tr><td><strong>reftest/</strong></td>
<td>es el directorio en el que se encuentra nuestro entorno de
pruebas de referencia para el kernel.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cargando-el-sistema">
<h2>Cargando el sistema<a class="headerlink" href="#cargando-el-sistema" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Zafio puede ser cargado por cualquier <em>bootloader</em> compatible con la
especificación Multiboot <a class="reference internal" href="background.html#multiboot">[Multiboot]</a>.</p>
<p>La especificación Multiboot es relativamente sencilla y existen
implementaciones estables de la misma. Además, la especificación
asegura algunas características interesantes que tendrán los
<em>bootloaders</em> que la implementen, como la obligación de prepararle al
kernel un estado inicial en modo protegido con la <em>gate A20</em> activada
y la capacidad de brindarle información sobre la memoria disponible,
entre otras.</p>
<div class="admonition note">
<p class="first admonition-title">Nota</p>
<p class="last">Si bien se utilizó GRUB (&#8220;Legacy&#8221;) como <em>bootloader</em> de referencia,
Zafio debería poder ser arrancado por cualquier <em>bootloader</em> que
cumpla la especificación Multiboot.</p>
</div>
<p>Una vez que el bootloader se ocupa de cargar Zafio en la memoria
principal, el código en <tt class="docutils literal"><span class="pre">kernel/src/loader.S</span></tt> toma el control. Este
código se ocupa, entre otras cosas, de construir la GDT definitiva del
sistema, inicializar estructuras necesarias para el manejo de la
memoria y activar el mecanismo de paginación de memoria que provee el
procesador (hablaremos más en detalle de esto en la sección
<a class="reference internal" href="#la-memoria">La memoria</a>).</p>
<p>El objetivo final de esta pieza de código es dejar todo listo para que
pueda darse la ejecución de código del kernel, escrito principalmente
en C, que se encuentra mapeado en direcciones virtuales altas (<em>higher
half</em>), por encima de los 3GB. Cuando esto es posible, se produce el
salto al código presente en <tt class="docutils literal"><span class="pre">kernel/src/kernel.c</span></tt> que se ocupa de
inicializar los diferentes subsistemas y comenzar la ejecución de la
primer tarea.</p>
</div>
<div class="section" id="manejo-de-procesos">
<h2>Manejo de procesos<a class="headerlink" href="#manejo-de-procesos" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La ejecución y el manejo de tareas (o procesos <a class="footnote-reference" href="#id3" id="id2">[1]</a>) es una parte
importante de cualquier sistema operativo. Zafio no es la excepción.</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Usamos los términos &#8220;tarea&#8221; y &#8220;proceso&#8221; de manera
intercambiable.</td></tr>
</tbody>
</table>
<div class="section" id="el-descriptor-de-proceso">
<h3>El descriptor de proceso<a class="headerlink" href="#el-descriptor-de-proceso" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Cada tarea es representada en el kernel por una estructura <tt class="docutils literal"><span class="pre">task_t</span></tt>,
cuya definición puede hallarse en <tt class="docutils literal"><span class="pre">kernel/inc/sched.h</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">task_t</span> <span class="p">{</span>
    <span class="c">// Informacion sobre el programa asociado a la tarea</span>
    <span class="k">struct</span> <span class="n">program_t</span> <span class="o">*</span><span class="n">prog</span><span class="p">;</span>

    <span class="c">// Direccion virtual del directorio de paginas en el</span>
    <span class="c">// espacio de direcciones del kernel</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">pd</span><span class="p">;</span>

    <span class="c">// Datos sobre el stack en espacio de kernel</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">kernel_stack</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">kernel_stack_pointer</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">kernel_stack_limit</span><span class="p">;</span>

    <span class="c">// Campo para identificacion del proceso</span>
    <span class="kt">uint32_t</span> <span class="n">pid</span><span class="p">;</span>

    <span class="c">// Informacion para el scheduling</span>
    <span class="kt">uint32_t</span> <span class="n">quantum</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">rem_quantum</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">ticks</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">waiting</span><span class="p">;</span>
    <span class="n">task_t</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
    <span class="n">bool</span> <span class="n">waited</span><span class="p">;</span>

    <span class="n">task_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">task_t</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Esta estructura contiene todo lo que el kernel precisa saber sobre la
tarea. Entre estas cosas, se encuentra la información sobre el programa
asociado a la tarea y sobre el espacio de direcciones virtual de la
misma e información utilizada para la planificación realizada por el
<em>scheduler</em> de procesos.</p>
</div>
<div class="section" id="el-scheduler">
<h3>El <em>scheduler</em><a class="headerlink" href="#el-scheduler" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El algoritmo de <em>scheduling</em> utilizado es extremadamente sencillo:
<em>round-robin</em> con <em>quantums</em> modificables. A cada tarea se le asigna,
inicialmente, un número fijo de unidades de tiempo para su ejecución.
Cada unidad de tiempo equivale a una interrupción del <em>timer</em>. El
<em>quantum</em> de cada tarea puede luego ser alterado mediante la llamada al
sistema <tt class="docutils literal"><span class="pre">nice()</span></tt>.</p>
<p>Las tareas pueden estar bloqueadas (<tt class="docutils literal"><span class="pre">waiting</span> <span class="pre">=</span> <span class="pre">TRUE</span></tt>) o disponibles
para ser ejecutadas (<tt class="docutils literal"><span class="pre">waiting</span> <span class="pre">=</span> <span class="pre">FALSE</span></tt>). Cuando están disponibles,
pueden encontrarse en ejecución o a la espera de su turno. Como el
kernel sólo maneja un único procesador, en todo momento hay a lo sumo
una única tarea en ejecución.</p>
<p>La administración se realiza mediante una lista doblemente enlazada
circular de procesos. La cabeza de esta lista es siempre el proceso
actualmente en ejecución. Cuando se acaba el <em>quantum</em> de una tarea, la
cabeza pasa a ser la siguiente tarea en la lista que se encuentre
en condiciones de ser ejecutada. Cuando una tarea finaliza su ejecución
(invocando ella misma a la llamada al sistema <tt class="docutils literal"><span class="pre">exit()</span></tt> o a causa de
una llamada a <tt class="docutils literal"><span class="pre">kill()</span></tt> por parte de otra tarea) esta es quitada de la
lista y los recursos que utilizaba son eventualmente liberados.</p>
</div>
<div class="section" id="creacion-de-tareas">
<h3>Creación de tareas<a class="headerlink" href="#creacion-de-tareas" title="Enlazar permanentemente con este título">¶</a></h3>
<p>La primer tarea que ingresa al sistema (llamada <tt class="docutils literal"><span class="pre">init</span></tt>) tiene a su
cargo la creación de las tareas correspondientes a los programas de
inicio. Puede observarse el código de esta tarea en el archivo
<tt class="docutils literal"><span class="pre">kernel/src/init.c</span></tt>.</p>
<p>Para la creación de tareas, tanto <tt class="docutils literal"><span class="pre">init</span></tt> como el resto de las tareas
hacen uso de la llamada al sistema <tt class="docutils literal"><span class="pre">run()</span></tt>, cuyo código puede
hallarse en <tt class="docutils literal"><span class="pre">kernel/src/syscalls.c</span></tt>. <tt class="docutils literal"><span class="pre">run()</span></tt> recibe el nombre de un
programa por parámetro y se encarga de:</p>
<ul class="simple">
<li>conseguir la información correspondiente al programa (entre lo que se
halla su ejecutable ELF),</li>
<li>crear la tarea asignándole un espacio de direcciones propio, mediante
<tt class="docutils literal"><span class="pre">create_task()</span></tt>,</li>
<li>agregar la tarea a la lista de tareas usando <tt class="docutils literal"><span class="pre">add_task()</span></tt>.</li>
</ul>
<p>Las funciones <tt class="docutils literal"><span class="pre">create_task()</span></tt> y <tt class="docutils literal"><span class="pre">add_task()</span></tt> se encuentran en el
archivo <tt class="docutils literal"><span class="pre">kernel/src/sched.c</span></tt>.</p>
<p>Hasta este punto, se reserva espacio para el descriptor del proceso y
para el stack del kernel de la tarea, pero la reserva y mapeo del
stack de usuario y del código y los datos de la tarea en su espacio de
direcciones virtual, utilizando la información en el ejecutable ELF
correspondiente, se realiza recién cuando a esta le toca ejecutarse
por primera vez. El código que se ocupa de esto se halla repartido
entre <tt class="docutils literal"><span class="pre">kernel/src/sched.c</span></tt>, <tt class="docutils literal"><span class="pre">kernel/src/sched_helpers.S</span></tt> y
<tt class="docutils literal"><span class="pre">kernel/src/progs.c</span></tt>.</p>
</div>
<div class="section" id="cambios-de-contexto">
<h3>Cambios de contexto<a class="headerlink" href="#cambios-de-contexto" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Zafio realiza los cambios de contexto de las tareas por <em>software</em>.
Como consecuencia, hay una única TSS que se utiliza al mínimo: Sólo
se utilizan el campo correspondiente al descriptor de segmento del
stack en modo kernel (<tt class="docutils literal"><span class="pre">SS0</span></tt>) y el correspondiente al <em>stack pointer</em>
en modo kernel (<tt class="docutils literal"><span class="pre">ESP0</span></tt>). Estos campos de la TSS son utilizados por el
hardware para cargar los registros <tt class="docutils literal"><span class="pre">SS</span></tt> y <tt class="docutils literal"><span class="pre">ESP0</span></tt> respectivamente al
ocurrir un cambio de nivel al nivel 0.</p>
<p>Los contextos de las tareas son resguardados en sus correspondientes
stacks de kernel. Al ocurrir una interrupción mientras se está
ejecutando una tarea, el <em>handler</em> de la interrupción inmediatamente
almacena el contexto de la tarea en el stack de modo kernel y luego
llama a la rutina de atención correspondiente (ver la sección <a class="reference internal" href="#manejo-de-interrupciones">Manejo
de interrupciones</a>).</p>
<p>Si la interrupción no deriva en un cambio de contexto, al terminar de
manejarla, simplemente se procede de manera inversa, cargando el estado
de la tarea desde el stack de kernel y volviendo a ejecutar en modo
usuario. Sin embargo, si la interrupción sí derivará en un cambio de
contexto, se procede del siguiente modo:</p>
<ul class="simple">
<li>se guarda el registro <tt class="docutils literal"><span class="pre">EFLAGS</span></tt> (<em>flags</em> del procesador)</li>
<li>se marca la siguiente tarea en la lista de tareas que se encuentre
lista para ser ejecutada como la tarea actual (de no existir tal
tarea, el sistema detiene su ejecución hasta que una interrupción
ocasione la aparición <a class="footnote-reference" href="#id5" id="id4">[2]</a> de una tarea en condiciones de ser ejecutada)</li>
<li>se carga el espacio de direcciones de la nueva tarea</li>
<li>se actualizan los valores de <tt class="docutils literal"><span class="pre">SS0</span></tt> y <tt class="docutils literal"><span class="pre">ESP0</span></tt> en la TSS del sistema</li>
<li>se almacena el <em>stack pointer</em> de modo kernel actual en el descriptor
de la tarea que estaba ejecutando y se carga el correspondiente a la
nueva tarea desde su descriptor</li>
</ul>
<p>El código de todo este procedimiento puede observarse en las funciones
<tt class="docutils literal"><span class="pre">switch_tasks()</span></tt> y <tt class="docutils literal"><span class="pre">switch_context()</span></tt> en <tt class="docutils literal"><span class="pre">kernel/src/sched.c</span></tt> y
en el <em>label</em> <tt class="docutils literal"><span class="pre">switch_stack_pointers</span></tt> en
<tt class="docutils literal"><span class="pre">kernel/src/sched_helpers.S</span></tt>.</p>
<p>Al retornar de la función que se ocupa del último punto, se buscará la
dirección de retorno en este &#8220;nuevo&#8221; stack. Si la tarea ya había estado
en ejecución, simplemente irá retornando hasta llegar a la parte en la
que se carga el contexto desde el stack y se vuelve a ejecutar en modo
usuario. No obstante, si la tarea es una tarea nueva, su stack fue
armado cuidadosamente de manera que al retornar de la función se
ejecute el código del label <tt class="docutils literal"><span class="pre">initialize_task</span></tt> en
<tt class="docutils literal"><span class="pre">kernel/src/sched_helpers.S</span></tt>. Esta porción de código es la encargada
de reservar memoria y realizar los mapeos que ya se nombraron antes en
<a class="reference internal" href="#creacion-de-tareas">Creación de tareas</a>.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>El caso común es que todas las tareas se encuentren a la espera
de algún evento. Por ejemplo, una tarea puede haber invocado a
la llamada <tt class="docutils literal"><span class="pre">waitpid()</span></tt> y encontrarse a la espera de que otra
tarea termine. Otra tarea puede estar esperando que se ingrese
algo en una terminal. En ese caso, al ocurrir la interrupción
del teclado y producirse el ingreso de datos, la tarea en espera
sería despertada y se encontraría lista para proseguir su
ejecución.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="manejo-de-interrupciones">
<h2>Manejo de interrupciones<a class="headerlink" href="#manejo-de-interrupciones" title="Enlazar permanentemente con este título">¶</a></h2>
<p>La función <tt class="docutils literal"><span class="pre">idt_init()</span></tt> en <tt class="docutils literal"><span class="pre">kernel/src/idt.c</span></tt> se ocupa de
inicializar el módulo de manejo de interrupciones. Para esto, escribe
los descriptores en la IDT para las interrupciones que serán manejadas.
Cada una de las entradas en la IDT se corresponde con un <em>handler</em>
distinto generado en <tt class="docutils literal"><span class="pre">kernel/src/idt_handlers.S</span></tt>. La razón por la que
hay un <em>handler</em> diferente por cada interrupción es porque es la única
forma de poder establecer qué interrupción se está atendiendo, ya que,
cuando ocurre una interrupción, se ejecuta el código cuya dirección fue
registrada en la IDT, pero el hardware no almacena información que
permita identificar de qué interrupción se trata.</p>
<p>Estas rutinas se encargan de guardar el contexto de la tarea en
ejecución en el stack de modo kernel y luego llaman a una función
común, llamada <tt class="docutils literal"><span class="pre">idt_handle()</span></tt>, pasándole a esta el índice en la IDT
de la interrupción ocurrida, un código de error si existiera y el
contexto guardado. De allí en más, <tt class="docutils literal"><span class="pre">idt_handle()</span></tt> es quien se ocupa
de delegar el manejo de la interrupción en rutinas de servicio,
escritas en C, que debieron ser registradas a través de
<tt class="docutils literal"><span class="pre">register_isr()</span></tt>. Si no hay una rutina de servicio registrada para la
interrupción, se llama a una rutina de servicio genérica por omisión.</p>
<p>Una vez que <tt class="docutils literal"><span class="pre">idt_init()</span></tt> escribió la IDT, registra algunas rutinas
de servicio, entre las cuales se encuentran la correspondiente al timer
(interrupción <tt class="docutils literal"><span class="pre">0x20</span></tt>) y la utilizada para recibir llamadas al sistema
(interrupción <tt class="docutils literal"><span class="pre">0x80</span></tt>) y da aviso al procesador de que tiene la IDT
lista. Por último, configura los PIC y desenmascara sólo las
interrupciones de <em>hardware</em> que le interesarán al kernel.</p>
</div>
<div class="section" id="atencion-de-llamadas-al-sistema">
<h2>Atención de llamadas al sistema<a class="headerlink" href="#atencion-de-llamadas-al-sistema" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Las llamadas al sistema se realizan a través de la interrupción
<tt class="docutils literal"><span class="pre">0x80</span></tt>. Antes de generar la interrupción por software, el proceso
debe escribir el número correspondiente a la llamada al sistema que
desea ejecutar en el registro <tt class="docutils literal"><span class="pre">EAX</span></tt>. Los parámetros de la llamada al
sistema deben pasarse usando los registros <tt class="docutils literal"><span class="pre">EBX</span></tt>, <tt class="docutils literal"><span class="pre">ECX</span></tt> y <tt class="docutils literal"><span class="pre">EDX</span></tt>.
Al ocurrir la interrupción, la rutina de servicio de la interrupción
<tt class="docutils literal"><span class="pre">0x80</span></tt> llama a la función correspondiente a la llamada al sistema
invocada con los parámetros pasados.</p>
<p>Las llamadas al sistema implementadas hasta ahora son:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="22%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Número</th>
<th class="head">Nombre</th>
<th class="head">Función</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>1</td>
<td><tt class="docutils literal"><span class="pre">exit()</span></tt></td>
<td>finaliza el proceso en ejecución y libera todos
los recursos utilizados por este</td>
</tr>
<tr><td>3</td>
<td><tt class="docutils literal"><span class="pre">read()</span></tt></td>
<td>lee de un dispositivo y almacena lo leído en un
buffer provisto por el usuario</td>
</tr>
<tr><td>4</td>
<td><tt class="docutils literal"><span class="pre">write()</span></tt></td>
<td>escribe en un dispositivo a partir de un buffer
provisto por el usuario</td>
</tr>
<tr><td>5</td>
<td><tt class="docutils literal"><span class="pre">ls()</span></tt></td>
<td>escribe información sobre los programas
disponibles en un buffer provisto por el
usuario</td>
</tr>
<tr><td>6</td>
<td><tt class="docutils literal"><span class="pre">ps()</span></tt></td>
<td>escribe información sobre los procesos del
sistema en un buffer provisto por el usuario</td>
</tr>
<tr><td>7</td>
<td><tt class="docutils literal"><span class="pre">run()</span></tt></td>
<td>crea una tarea para el programa que recibe por
parámetro</td>
</tr>
<tr><td>8</td>
<td><tt class="docutils literal"><span class="pre">devreq()</span></tt></td>
<td>pide al kernel que se asigne un dispositivo
específico a la tarea en ejecución</td>
</tr>
<tr><td>9</td>
<td><tt class="docutils literal"><span class="pre">devrel()</span></tt></td>
<td>avisa al kernel que un dispositivo usado por la
tarea en ejecución ya puede ser liberado</td>
</tr>
<tr><td>10</td>
<td><tt class="docutils literal"><span class="pre">nice()</span></tt></td>
<td>permite cambiar el quantum de una tarea</td>
</tr>
<tr><td>11</td>
<td><tt class="docutils literal"><span class="pre">waitpid()</span></tt></td>
<td>permite a una tarea bloquearse hasta la
terminación de una tarea hija</td>
</tr>
<tr><td>12</td>
<td><tt class="docutils literal"><span class="pre">kill</span></tt></td>
<td>elimina a una tarea de la lista de tareas y
libera los recursos que esta ocupaba</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="la-memoria">
<h2>La memoria<a class="headerlink" href="#la-memoria" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="gestion-de-la-memoria">
<h3>Gestión de la memoria<a class="headerlink" href="#gestion-de-la-memoria" title="Enlazar permanentemente con este título">¶</a></h3>
<p>El <em>bootloader</em> Multiboot es capaz de proveer información sobre la
memoria física del sistema. Zafio saca provecho de eso. Al iniciar,
utiliza los datos sobre la memoria brindados por el <em>bootloader</em> y
asigna una estructura <tt class="docutils literal"><span class="pre">page_t</span></tt> por cada página física disponible para
ser usada.  Dicha estructura se encuentra declarada en
<tt class="docutils literal"><span class="pre">kernel/inc/vmm.h</span></tt> del siguiente modo:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">page_t</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">page_t</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">page_t</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">kvaddr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Los punteros <tt class="docutils literal"><span class="pre">next</span></tt> y <tt class="docutils literal"><span class="pre">prev</span></tt> son utilizados para administrar la
lista de páginas físicas libres, <tt class="docutils literal"><span class="pre">count</span></tt> indica el número de
referencias de la página y <tt class="docutils literal"><span class="pre">kvaddr</span></tt> representa la dirección virtual
en la que está mapeada (si lo está).</p>
<p>En <tt class="docutils literal"><span class="pre">kernel/src/vmm.c</span></tt> se encuentran todas las funciones que se ocupan
de gestionar las páginas físicas libres y de mapearlas a los espacios
de direcciones virtuales.</p>
<p>En <tt class="docutils literal"><span class="pre">kernel/src/heap.c</span></tt> se encuentran las funciones <tt class="docutils literal"><span class="pre">kmalloc()</span></tt> y
<tt class="docutils literal"><span class="pre">kfree()</span></tt>, una implementación de un <em>heap</em> para pedidos de memoria
arbitrarios.</p>
</div>
<div class="section" id="direccionamiento">
<h3>Direccionamiento<a class="headerlink" href="#direccionamiento" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Una de las primeras cosas que se realizan en <tt class="docutils literal"><span class="pre">kernel/src/loader.S</span></tt>
(el código al que salta el bootloader) es configurar una GDT definitiva
para el sistema. La misma está compuesta por descriptores para:</p>
<ol class="arabic simple">
<li>Código de nivel 0</li>
<li>Datos de nivel 0</li>
<li>Código de nivel 3</li>
<li>Datos de nivel 3</li>
<li>TSS del sistema</li>
</ol>
<p>Tanto los segmentos de código como de datos ocupan todo el espacio
direccionable. El principal mecanismo de protección de memoria
utilizado en Zafio es la paginación.</p>
<p>Cada tarea tiene su propio espacio de memoria virtual. La siguiente es
una representación del mismo para una tarea cualquiera:</p>
<div class="highlight-c"><pre>+----------------------------+ 0x00000000   \
| ...                        |               |
+----------------------------+ 0x08048000    |
| Código y datos de la tarea |               |
+----------------------------+ ~0x0804A000   |
| ...                        |               |
| ...                        |               |
+----------------------------+ 0x3FFFF000    |
| Stack de la tarea          |               |
+----------------------------+ 0x40000000    |
| ...                        |               |
| ...                        |               |
+----------------------------+ 0x60000000    |  Lower half (usuario)
| start_task(main)           |               |
+----------------------------+ 0x60001000    |
| ...                        |               |
| ...                        |               |
| ...                        |               |
| ...                        |               |
| ...                        |               |
| ...                        |              /
+----------------------------+ 0xC0000000       &lt;--- 3GB
| ...                        |              \
+----------------------------+ 0xC00B8000    |
| Memoria de video           |               |
+----------------------------+ 0xC00B9000    |
| ...                        |               |
+----------------------------+ 0xC0100000    |
| Loader                     |               |
+----------------------------+ 0xC0101000    |
| Stack del kernel           |               |
+----------------------------+ 0xC0103000    |
| Directorio de paginas del  |               |
| kernel                     |               |
+----------------------------+ 0xC0104000    |  Higher half (kernel)
| Tablas de paginas          |               |
| ...                        |               |
+----------------------------+ 0xC0200000    |
| Codigo y datos del kernel  |               |
+----------------------------+ 0xC02XXXXX    |
| Estructuras page_t         |               |
+----------------------------+ 0xCXXXXXXX    |
|           ...              |               |
|           ...              |               |
|           ...              |               |
|           ...              |               |
|           ...              |               |
|           ...              |              /
+----------------------------+ 0xFFFFFFFF</pre>
</div>
<p>Como se puede ver, el código y los datos del kernel se encuentran
siempre en las direcciones altas (<em>higher half</em>) de los espacios de
memoria de las tareas, mientras que el código y los datos de usuario se
encuentran en la parte baja.</p>
<p>La memoria de usuario (debajo de los 3GB) incluye el código de la
tarea, un área para sus datos y su stack. Además, se encuentra mapeada
en esta parte la función <tt class="docutils literal"><span class="pre">start_task()</span></tt>. Esta función es la que
recibe el control al cargar una tarea nueva. Recibe como parámetro la
función que oficia de punto de entrada de la tarea, ya mapeada en el
espacio de direcciones virtual, y sólo se ocupa de llamar a esa función
y, si esta retorna, invocar la llamada al sistema <tt class="docutils literal"><span class="pre">exit()</span></tt>. De este
modo, una vez que la función de punto de entrada de la tarea finaliza,
la tarea y los recursos que esta ocupa son liberados.</p>
<p>La memoria del kernel tiene una parte mapeada a la memoria física con
un <em>offset</em> de 3GB. Por ejemplo, la dirección virtual <tt class="docutils literal"><span class="pre">0xC00B8000</span></tt> se
corresponde con la dirección física <tt class="docutils literal"><span class="pre">0x000B8000</span></tt>, donde se encuentra
la memoria de video. Otras cosas mapeadas en las direcciones altas del
espacio de memoria virtual son los directorios y tablas de páginas y
demás estructuras para la administración de memoria y, por supuesto, el
código del kernel.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="static/zeta.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Contenidos</a></h3>
  <ul>
<li><a class="reference internal" href="#">Zafio por dentro</a><ul>
<li><a class="reference internal" href="#la-estructura-de-directorios">La estructura de directorios</a></li>
<li><a class="reference internal" href="#cargando-el-sistema">Cargando el sistema</a></li>
<li><a class="reference internal" href="#manejo-de-procesos">Manejo de procesos</a><ul>
<li><a class="reference internal" href="#el-descriptor-de-proceso">El descriptor de proceso</a></li>
<li><a class="reference internal" href="#el-scheduler">El <em>scheduler</em></a></li>
<li><a class="reference internal" href="#creacion-de-tareas">Creación de tareas</a></li>
<li><a class="reference internal" href="#cambios-de-contexto">Cambios de contexto</a></li>
</ul>
</li>
<li><a class="reference internal" href="#manejo-de-interrupciones">Manejo de interrupciones</a></li>
<li><a class="reference internal" href="#atencion-de-llamadas-al-sistema">Atención de llamadas al sistema</a></li>
<li><a class="reference internal" href="#la-memoria">La memoria</a><ul>
<li><a class="reference internal" href="#gestion-de-la-memoria">Gestión de la memoria</a></li>
<li><a class="reference internal" href="#direccionamiento">Direccionamiento</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="background.html" title="Capítulo anterior">Un poco de <em>background</em></a></li>
      <li>Next: <a href="install.html" title="Próximo capítulo">Instalación y uso</a></li>
  </ul></li>
</ul>
  <h3>Esta página</h3>
  <ul class="this-page-menu">
    <li><a href="sources/zafio.txt"
           rel="nofollow">Enseñar el código</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Búsqueda rápida</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Ir a" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Introduzca los términos de búsqueda o un módulo, clase o nombre de función.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy; Copyright 2010, Pablo Antonio.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
    </div>
  </body>
</html>